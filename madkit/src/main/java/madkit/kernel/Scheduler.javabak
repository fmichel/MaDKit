package madkit.kernel;

import static madkit.kernel.Scheduler.SimulationState.PAUSED;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collection;
import java.util.logging.Level;

import org.controlsfx.control.action.Action;
import org.controlsfx.control.action.ActionGroup;
import org.controlsfx.control.action.ActionUtils;
import org.controlsfx.control.action.ActionUtils.ActionTextBehavior;

import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.scene.Scene;
import javafx.scene.control.Slider;
import javafx.scene.control.ToolBar;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.BorderPane;
import madkit.action.SchedulingAction;
import madkit.gui.fx.FXManager;
import madkit.messages.SchedulingMessage;
import madkit.simulation.SimulationTime;

/**
 * <pre>
 * Scheduler is the core agent for defining multi-agent based simulations.
 *
 * This class defines a generic threaded agent which is in charge of activating
 * the simulated agents using {@link Activator}. {@link Activator} are tool
 * objects which are able to trigger any available method belonging to the
 * agents that have a role within a group.
 *
 * The purpose of this approach is to allow the manipulation of agents
 * regardless of their concrete Java classes.
 *
 * So a scheduler holds a collection of activators that target specific groups
 * and roles and thus allow to define very complex scheduling policies if
 * required. A default behavior is implemented and corresponds to the triggering
 * of the activators according to the order in which they have been added to the
 * scheduler engine using {@link #addActivator(Activator)}.
 *
 * The default state of a scheduler is {@link SimulationState#PAUSED}.
 *
 * The default delay between two simulation steps is 0 milliseconds (max speed).
 *
 * Default GUI components are defined for this agent and they could be easily
 * integrated in any GUI.
 * </pre>
 * 
 * As of MaDKit 5.3, two different temporal schemes could used:
 * <ul>
 * <li>tick-based: The time is represented as a {@link BigDecimal} which is
 * incremented at will. {@link BigDecimal} is used to avoid rounding errors that
 * may happen when working with double values. This is the preferred choice if
 * the simulation is based on simple loop following a discrete time approach.
 *
 * <li>date-based: The time is represented using {@link LocalDateTime}. This is
 * far more convenient when the model refers to a real-world case for which
 * representing usual temporal units such as hours or weeks is required (the
 * default used unit is {@link ChronoUnit#SECONDS}). This mode also allow to
 * handle agents that evolve considering different time scales or during
 * specific period of the day.
 * </ul>
 *
 * Those two modes are exclusive and can be selected using the corresponding
 * constructor of the scheduler
 *
 * @author Fabien Michel
 * @since MaDKit 2.0
 * @version 5.3
 * @see Activator
 * @see BigDecimal
 * @see LocalDateTime
 */
public class Scheduler<T extends SimulationTime> extends AbstractScheduler<T> {

	private SimulationState simulationState = SimulationState.PAUSED;

	private Action run, step, speedUp, speedDown;

	private IntegerProperty pause = new SimpleIntegerProperty(0);
	
			

	/**
	 * Returns the delay between two simulation steps
	 * 
	 * @return the pause between two steps
	 */
	public int getPause() {
		return pause.get();
	}

	public void setPause(int delay) {
		pause.set(delay);
//		mySlider.setValue(delay);
	}
	
	@Override
	public void setupGUI() {
		FXManager.runAndWait(() -> {
			AgentFxStage stage = new AgentFxStage(this);
			BorderPane root = new BorderPane();
			ToolBar tb = getToolBar();
			root.setTop(tb);
			Scene scene = new Scene(root);
//		slider.valueProperty().addListener(new javafx.beans.value.ChangeListener<Number>() {
//			@Override public void changed(ObservableValue<? extends Number> observableValue, Number oldValue, Number newValue) {
//				if (newValue == null) {
//					System.out.println("null");
//				}
//				System.out.println("CHANGED "+newValue);
//				System.out.println("pause "+pause.doubleValue());
//			}
//		});
			
			stage.setScene(scene);
			stage.sizeToScene();
			stage.show();
		});
		System.out.println("pause " + pause.doubleValue());
	}

	/**
	 * @return
	 */
	public Slider getNewPauseSlider() {
		Slider slider = new Slider(0, 400, 10);
		slider.setMinWidth(200);
		slider.setShowTickLabels(true);
		slider.setShowTickMarks(true);
		slider.setMajorTickUnit(10);
		slider.setMinorTickCount(1);
		slider.setBlockIncrement(1);
		slider.setSnapToTicks(true);
		pause.bindBidirectional(slider.valueProperty());
		slider.setOnScroll((ScrollEvent event) -> {
			slider.setValue(pause.getValue() + (event.getDeltaY()>0 ? 1 : -1));
		});
		mySlider = slider;
		return slider;
	}

	/**
	 * @return
	 */
	public ToolBar getToolBar() {
		Collection<Action> actions = new ArrayList<>();
		actions.add(run);
		actions.add(step);
		ActionGroup group = new ActionGroup("Scheduling", actions);

//		ToolBar tb = ActionUtils.createToolBar(SchedulingAction.createAgentFxActionGroup(this).getActions(),
//				ActionTextBehavior.HIDE);
		ToolBar tb = ActionUtils.createToolBar(actions,ActionTextBehavior.HIDE);
		tb.getItems().add(getNewPauseSlider());
		tb.getItems().add(getTimeLabel());
		return tb;
	}

	private Slider mySlider;

	/**
	 * Constructs a <code>Scheduler</code> using a tick-based
	 * {@link SimulationTime}.
	 */
	public Scheduler() {
		buildActions();
//		getNewPauseSlider();
	}

	/**
	 * Defines a default simulation loop which is automatically during the
	 * scheduler's life.
	 *
	 * This method should be overridden to define a customized scheduling policy.
	 *
	 * By default, it executes all the activators in the order they have been added,
	 * using {@link Activator#execute(Object...)}, and then increments the
	 * simulation time by one unit. Default implementation is:
	 *
	 * <pre>
	 * logActivationStep();
	 * for (final Activator<? extends Agent> activator : activators) {
	 * 	executeAndLog(activator);
	 * }
	 * getSimulationTime().addOneTimeUnit();
	 * </pre>
	 *
	 * By default logs are displayed only if {@link #getLogger()} is set above
	 * {@link Level#FINER}.
	 */
	public void doSimulationStep() {
		logCurrrentStep();
		executeActivators();
		getSimulationTime().addOneTimeUnit();
	}

	@Override
	protected void end() {
		simulationState = PAUSED;
		getLogger().fine(() -> "Simulation stopped at time = " + getSimulationTime());
	}

	/**
	 * The state of the simulation.
	 *
	 * @return the state in which the simulation is.
	 * @see SimulationState
	 */
	public SimulationState getSimulationState() {
		return simulationState;
	}
	
	/**
	 * Scheduler's default behavior. default code is:
	 *
	 * <pre>
	 * while (isAlive()) {
	 * 	if (GVT &gt; getSimulationDuration()) {
	 * 		if (logger != null)
	 * 			logger.info(&quot;Simulation has reached end time -> &quot; + getSimulationDuration());
	 * 		return;
	 * 	}
	 * 	pause(getDelay());
	 * 	checkMail(nextMessage());
	 * 	switch (getSimulationState()) {
	 * 	case RUNNING:
	 * 		doSimulationStep();
	 * 		break;
	 * 	case PAUSED:
	 * 		paused();
	 * 		break;
	 * 	case STEP:
	 * 		simulationState = PAUSED;
	 * 		doSimulationStep();
	 * 		break;
	 * 	case SHUTDOWN:
	 * 		return; // shutdown
	 * 	default:
	 * 		getLogger().severe(&quot;state not handled &quot; + getSimulationState);
	 * 	}
	 * }
	 * </pre>
	 *
	 * @see madkit.kernel.Agent#live()
	 */
	@Override
	protected void live() {
		while (!Thread.currentThread().isInterrupted()) {
			if (getSimulationTime().hasReachedEndTime()) {
				getLogger().info(() -> "Simulation has reached end time -> " + getSimulationTime());
				return;
			}
			pause(pause.get());
			checkMail(nextMessage());
			switch (simulationState) {
			case RUNNING:
				doSimulationStep();
				break;
			case PAUSED:
				paused();
				break;
			case STEP:
				simulationState = PAUSED;
				doSimulationStep();
				break;
			case SHUTDOWN:
				return; // shutdown
			default:
//				getLogger().severeLog("state not handled " + simulationState);
			}
		}
	}

	/**
	 * Changes my state according to a {@link SchedulingMessage} and sends a reply
	 * to the sender as acknowledgment.
	 *
	 * @param m the received message
	 */
	protected void checkMail(final Message m) {
		if (m != null) {
			try {
				SchedulingAction code = ((SchedulingMessage) m).getCode();
				switch (code) {
				case RUN:
					setSimulationState(SimulationState.RUNNING);
					break;
				case STEP:
					setSimulationState(SimulationState.STEP);
					break;
				case PAUSE:
					setSimulationState(SimulationState.PAUSED);
					break;
//				case SHUTDOWN:
//					setSimulationState(SimulationState.SHUTDOWN);
//					break;
//				case SPEED_UP:
//					speedModel.setValue(speedModel.getValue() - 50);
//					break;
//				case SPEED_DOWN:
//					speedModel.setValue(speedModel.getValue() + 50);
//					break;
				}
				if (m.getSender() != null) {
					reply(m, m);
				}
			} catch (ClassCastException e) {
				getLogger().warning(() -> "I received a message that I cannot understand" + m);
			}
		}
	}

	/**
	 * Runs {@link #checkMail(Message)} every 1000 ms.
	 */
	protected void paused() {
		checkMail(waitNextMessage(1000));
	}

	private void buildActions() {
		run = SchedulingAction.RUN.getFxActionFor(this);
		step = SchedulingAction.STEP.getFxActionFor(this);
//		speedUp = SchedulingAction.SPEED_UP.getFxActionFor(this);
//		speedDown = SchedulingAction.SPEED_DOWN.getFxActionFor(this);
	}

	/**
	 * Changes the state of the scheduler
	 *
	 * @param newState the new state
	 */
	protected void setSimulationState(final SimulationState newState) {// TODO proceedEnumMessage
		if (simulationState != newState) {
			simulationState = newState;
			switch (simulationState) {
			case STEP:
				run.setDisabled(false);
				break;
			case PAUSED:
				run.setDisabled(false);
				break;
			case RUNNING:
				run.setDisabled(true);
				break;
			case SHUTDOWN:
				run.setDisabled(true);
				break;
			default:// impossible
			}
		}
	}

//	private void buildActions() {
//		run = SchedulingAction.RUN.getActionFor(this);
//		step = SchedulingAction.STEP.getActionFor(this);
//		speedUp = SchedulingAction.SPEED_UP.getActionFor(this);
//		speedDown = SchedulingAction.SPEED_DOWN.getActionFor(this);
//	}

	/**
	 * A simulation state. The simulation process managed by a scheduler agent can
	 * be in one of the following states:
	 * <ul>
	 * <li>{@link #RUNNING}<br>
	 * The simulation process is running normally.</li>
	 * <li>{@link #STEP}<br>
	 * The scheduler will process one simulation step and then will be in the
	 * {@link #PAUSED} state.</li>
	 * <li>{@link #PAUSED}<br>
	 * The simulation is paused. This is the default state.</li>
	 * </ul>
	 *
	 * @author Fabien Michel
	 * @since MaDKit 5.0
	 * @see #getSimulationState
	 */
	public enum SimulationState {
		/**
		 * The simulation process is running normally.
		 */
		RUNNING,

		/**
		 * The scheduler will process one simulation step and then will be in the
		 * {@link #PAUSED} state.
		 */
		STEP,

		/**
		 * The simulation is paused.
		 */
		PAUSED,

		/**
		 * The simulation is ending
		 */
		SHUTDOWN
	}

	public static void main(String[] args) {
		executeThisAgent();
	}
}
